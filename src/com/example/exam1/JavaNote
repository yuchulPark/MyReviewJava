/*

%d - 형식 지정 문자 (숫자 형식 출력(?))
%f - 실수를 출력
%.2f - 실수를 소수 두번째 자리까지 출력
%s - String 형식을 출력
toString - 어떤 클래스의 속성들을 표현하는 문자열을 반환함
		 - 출력문의 객체가 있으면 (출력문에 객체를 표현하고 싶으면) toString을 찾음

do-while문 - 조건이 안 맞아도 적어도 반복문을 한 번이라도 실행하고, 뒤에가서 조건을 확인함

메소드 - 어떤 일처리를 위한 서로 관련있는 명령어들의 집합
클래스 - 속성(맴버 변수)와 동작(맴버 메소드)으로 구성됨
클래스 변수 - 정적 변수, static 변수랑 같은 말
		- 클래스의 맴버 변수들은 일반적으로 객체를 생성해야 메모리가 확보되고, 객체마다 별도의 메모리 공간을 갖음.
		     또, 그것을 사용하기 위해서는 반드시 객체를 통해서 사용할 수 있음.
		     그런데 만약 모든 객체가 공동으로 사용할 기억공간이 필요하다면 or 객체 없이도 사용할 기억공간이 필요하다면 클래스 변수를 사용함
		- 맴버 변수명 앞에 static 키워드를 붙이면 이것이 클래스 변수(정적 변수)라고 하고, 객체를 생성하지 않아도 프로그램 실행하면 가장 먼저 메모리가 확보됨
		- 클래스 이름으로 접근 (만약 객체가 있다면 객체를 통해서도 접근 가능) 
클래스 메소드 - 어떤 클래스의 맴버 메소드를 사용하기 위해서는 반드시 그 클래스의 객체를 생성하고, 객체를 통해서만 사용 가능
		 - 만약 객체 없이도 어떤 메소드를 사용하도록 하려면 메소드 이름 앞에 static 키워드를 붙여 클래스 메소드를 만들어야함
		 - 객체 없이 접근해야 하니 클래스 이름으로 접근함 (만약 객체가 있다면 객체를 통해서도 접근 가능)
		 - ★★★클래스 메소드 안에서는 클래스 맴버에만 접근할 수 있고, 객체를 생성해야지만 사용할 수 있는 일반 맴버에는 접근할 수 없음
클래스 이름 앞에 public - 클래스 이름 앞에는 public 접근명시자만 올 수 있음 (private, protected 등은 올 수 없음)
				  - 클래스 이름 앞에는 public 접근명시자를 붙이거나 생략하는 두 가지 경우가 있음
				  - 클래스 이름 앞에 접근명시자가 생략된 것은 friendly의 개념임 
				    (friendly란 이 클래스가 속해있는 동일한 패키지는 모두 친구로 생각하여 이 클래스를 사용할 수 있음을 나타냄)
				  - 만약 이 클래스를 외부의 다른 패키지에서도 사용할 수 있도록 하려면 public 접근명시자를 붙이면 됨

생성자(Constructor) - 클래스 이름과 같은 이름을 갖는 특별한 메소드
				  - 객체 생성시에 자동 수행되어 속성(맴버 변수)들을 초기화 할 목적으로 사용
				  - 즉, 생성자 앞에 return을 적지 않음 (void라고 적으면 절대 안됨)
				  - 일반 메소드처럼 호출문에 의해서 동작하지 않고, 객체 생성시에 자동 수행되므로 return이라는 개념이 없음
				  - 때에 따라 중복하여 만들 수 있음. 생성자를 중복하여 정의하기 위해서는 매개변수의 개수가 다르거나 자료형이 달라야함
				  - 만약 사용자가 생성자를 하나도 만들지 않으면 자바는 기본 생성자를 제공함 (매개변수를 하나도 갖지 않는 생성자)
				  - 만약 사용자가 생성자를 정의하기 시작하면 더 이상 기본 생성자를 제공하지 않으므로 기본 생성자가 필요하다면 사용자가 따로 만들어야 함 
				  - 접근해서 값을 변경 : setter
				  - 접근해서 값을 불러옴 : getter

this - 생성자나 메소드의 매개변수 이름을 의미있는 이름으로 정해주다 보면 클래스의 맴버변수 이름(속성)과 이름과 같아짐
	       이때 맴버 자신을 구별할 목적으로 사용
this() - 생성자가 중복 정의되어 있을 때 나 말고 다른 생성자를 동작시키고자 할 때 사용
	   - 반드시 생성자의 첫 번째 문장에 와야함

객체지향 프로그래밍의 특징 - 은닉성 (Encapsulation) - 외부의 다른 클래스로부터 맴버 변수(속성)를 보호하는게 목적
				 - 상속성 (Inheritance) - 이미 만들어둔 클래스를 확장하여 새로운 클래스를 만들 수 있음
				 - 다형성 ()
				 
protected 접근 명시자 - 외부의 다른 클래스로부터는 보호하되 상속받는 자식 클래스에게는 접근을 허용하고자 할 경우 사용

메소드의 overriding - 상속 관계에 있을 때 부모로부터 물려받은 메소드가 자식 클래스에게는 맞지 않아 자식이 메소드를 자신에게 맞도록 다시 정의하는 것 (재정의)
				   (만약 부모로부터 물려받은 메소드가 자신에게도 알맞다면 그대로 사용할 수 있음. 즉, 자식의 입장에서 overriding할지 말지 선택할 수 있음)
				 - 메소드 오버라이딩이 되기 위해서는 메소드 이름뿐 아니라 매개변수의 개수와 자료형까지 일치되게 재정의 되어야 함
				 - 상속받은 자식 클래스는 부모의 모든 속성과 동작을 마치 자신의 것처럼 사용할 수 있음

추상 클래스 & 추상 메소드 
- 미래에 만들어질 자식 클래스들이 가져야할 공통적인 속성과 동작을 뽑아서 미리 부모 클래스를 만들음 
  (이 때 어떠한 메소드를 구체화 할 수 없고, 이 메소드는 반드시 자식 클래스들이 가져야 하며 오버라이딩할 것을 강제화 하고 있음)
  - 이러한 메소드에는 body를 구체화 하지 않고, 메소드 선언만 함으로써 추상 메소드를 만들음 (메소드명 앞에 추상 메소드임을 표시하기 위한 abstract라는 키워드를 붙임)
- 어떤 클래스가 추상 메소드를 하나라도 갖고 있다면 그 클래스 자신이 추상 클래스가 되어야함	    
- 추상 클래스는 body가 구체화 되지 않은 메소드를 갖고있기 때문에 객체는 생성할 수 없음	    
	    
equals 메소드 - 기본 자료형의 값이 서로 같은지 판별하기 위해서는 == 연산자를 사용하는데 참조 자료형에 == 연산자를 사용하게 되면 둘이 같은 메모리를 바라보는지 검사함 
			 (두 개의 객체가 서로 동일한 값을 갖고 있어도 false를 반환)
			 - 만약 두 개의 객체가 서로 동일한 속성값을 갖고있는지 판별하려면 object equals를 나한테 맞게 재정의 해야함

final - static과 같이 사용함
	  - 맴버 변수명 앞에 - 처음 정해준 값 이외의 변경 금지 (상수로 만들고자 할 때)
	  - 맴버 메소드 앞에 - 상속할 때 overriding 금지
	  - 클래스 이름 앞에 - 다른 클래스와의 상속 금지
	    
interface - 구현한다는 뜻
		  - 자바는 클래스의 다중 상속이 금지되어 있음. 다중 상속의 효과를 기대할 목적으로 인터페이스 사용
		  - 완전 추상의 개념 
			- 추상 메소드와 상수만으로 구성되어야 함 (마디가 없어야됨)	    
	    	- 메소드 선언문만 와야하고, 메소드 앞에 abstract을 생략해도 되고, 변수명 앞에 final을 생략해도 됨
	    
부모 클래스의 참조 변수와 자식 객체
- 상속 관계에 있을 때 부모 클래스의 참조 변수는 자식 객체를 생성하거나 참조할 수 있음
  - 부모 클래스의 참조 변수를 통해 메소드를 호출할 때 만약 어떠한 메소드가 부모 클래스에 있고, 자식 클래스에도 동일한 이름의 메소드가 있다면 (즉, overriding한 메소드가 있다면)
	이 참조 변수가 바라보는 객체를 평가하여 그 객체가 갖고 있는 (자식이 갖고 있는) overriding한 메소드가 호출됨
  - 그런데 부모 클래스는 없고, 자식 클래스에서 추가된 메소드를 호출하려면 자식 클래스의 자료형으로 형변환 후 호출해야함
  - 이때, 특정 클래스형의 자료형인지 판별하여 형변환할 필요가 있는데 그 때 사용하는 연산자가 instanceof 연산자임
    (if(a instanceof Shape){ : a가 Shape의 변수인가? -> 맞으면 형변환 함)
	    
컬렉션 프레임워크
- 많은 양의 자료 처리를 위해서는 일반적으로 배열을 사용하는데 배열은 다음과 같은 단점을 갖고 있음
  - 자료형이 동일한  것만 담을 수 있음
  - 자료의 추가, 삭제가 번거로움
- 이러한 단점을 해결하기 위해서 컬렉션 프레임워크를 사용 (Set, List, Map)
- 공통점 - 담고 싶은 자료형이 달라도 됨
	  - 추가/삭제가 용이로움
	  - 모두 인터페이스이며 이것들을 구현한 다양한 클래스들이 있음
	  
Set - 중복 허용 X
	- HashSet - 중복 허용 X
			  - 데이터의 순서 상관 X
	- LinkedHashSet - 중복 허용 X
					- 데이터의 순서 유지
	- TreeSet - 중복 허용 X
			  - 데이터의 순서는 값의 크기에 따라 정렬함
List - 중복 허용 O
	 - ArrayList - 중복 허용 O
	 			 - 데이터의 순서 유지
	 			 - 어떤 자료형이라도 담을 수 있음
	 - LinkedList - 중복 허용 O
	 			  - 데이터의 순서 유지
	 			  - 어떤 자료형이라도 담을 수 있음
	 			  - 데이터를 추가/삭제시 ArrayList보다 더 유용함
Map - key, value가 한 쌍으로 이루어진 자료 구조	 			  	  
	- HashMap, LinkedHashMap, TreeMap
	    
is a 관계 - 이미 있는 클래스를 확장하여 자식 클래스를 만드는 것
		- 상속 관계
		- 형변환 가능
has a 관계 - 이미 있는 다른 클래스를 맴버 변수로 갖는 것

Wrapper 클래스 - 기본 자료형을 참조 자료형(객체)으로 만들어주는 클래스
			- 서로 다른 자료형끼리의 형변환을 위해서도 사용
			- 자바가 제공하는 어떠한 기능을 사용할 때 기본 자료형을 취급하지 않고 객체만 상대하는 메소드들이 있음. 
			    이런 메소드를 사용하려면 Wrapper 클래스들을 이용하여 기본 자료형의 데이터를 객체로 만들어야 함 
			  (ex. int -> Integer)

다형성 - 객체에게 준 메시지는 동일한데(호출하는 메시지는 동일한데) 객체마다 동작 방식이(하는 일이) 다른 것

문자열 처리 - 자바에서는 문자열 처리를 위하여 String, StringBuffer, StringBuilder 클래스를 제공
		- String - 변하지 않는 문자열 처리에 적합
		- StringBuffer, StringBuilder - 변하는 문자열 처리에 적합
	




	    
*/